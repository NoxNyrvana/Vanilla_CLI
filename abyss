#!/usr/bin/env python3
"""
Abyss - terminal editor for prompt_toolkit v2.0.10
(…entier comme ton original, avec ajouts pour lancer/stopper GUI/ncurses/term)
"""
import sys
import os
import subprocess
import re
import glob
import socket
import webbrowser
import shutil
import signal
import time
from pathlib import Path
from prompt_toolkit import Application
from prompt_toolkit.key_binding import KeyBindings
from prompt_toolkit.layout import Layout, VSplit, HSplit, FloatContainer, Float, Window
from prompt_toolkit.layout.controls import FormattedTextControl
from prompt_toolkit.widgets import TextArea, Button, Dialog
from prompt_toolkit.lexers import PygmentsLexer
from prompt_toolkit.document import Document
from prompt_toolkit.application import get_app

# Pygments lexers (best-effort)
try:
    from pygments.lexers import (
        CLexer, CppLexer, PythonLexer, BashLexer, JsonLexer, SqlLexer,
        NasmLexer, CSharpLexer, HtmlLexer, JavascriptLexer
    )
except Exception:
    from pygments.lexers import CLexer, PythonLexer, BashLexer, JsonLexer, SqlLexer
    CppLexer = CLexer
    NasmLexer = CLexer
    CSharpLexer = CLexer
    HtmlLexer = CLexer
    JavascriptLexer = CLexer  # petite faute corrigée

# Globals
CURRENT_FILE = None
SPLIT_VIEW = False
CURRENT_MODE = "c"
HTML_SERVER_STARTED = False  # éviter plusieurs serveurs

# NEW: processes en cours (clé -> subprocess.Popen)
RUNNING_PROCS = {}  # ex: RUNNING_PROCS["gui_python"] = Popen(...)
# Key to identify the "session" we spawn for Ctrl-L toggle
TOGGLE_KEY = "ctrl_l_process"

# --- Text widgets ---
editor = TextArea(
    text="",
    multiline=True,
    line_numbers=True,
    wrap_lines=False,
    lexer=PygmentsLexer(CLexer),
    scrollbar=True,
    focus_on_click=True
)

output = TextArea(
    text="(Results will appear here)",
    multiline=True,
    read_only=True,
    wrap_lines=True,
    scrollbar=True
)

editor_window = Window(content=editor.control, wrap_lines=False)
output_window = Window(content=output.control, wrap_lines=True)

left_gutter = Window(width=2, char=" ")
middle_gap = Window(width=2, char=" ")

title_bar = Window(
    height=1,
    content=FormattedTextControl([('reverse', ' Abyss ')]),
    style='reverse'
)

body_container = VSplit([left_gutter, editor_window], padding=1)
root_container = FloatContainer(content=HSplit([title_bar, body_container]), floats=[])
layout_main = Layout(root_container, focused_element=editor_window)

# ---- Helper functions ----
def save_file(filename: str):
    global CURRENT_FILE
    CURRENT_FILE = filename
    with open(filename, "w", encoding="utf-8") as f:
        f.write(editor.text)
    output.text = f"Saved to {filename}"

def open_save_dialog():
    fname_input = TextArea(multiline=False, height=1, text=CURRENT_FILE or "")
    kb_dialog = KeyBindings()

    def on_ok():
        fname = fname_input.text.strip()
        root_container.floats[:] = []
        if fname:
            save_file(fname)
            get_app().exit(result=fname)
        else:
            output.text = "error vanilla 403"
            layout_main.focus(editor_window)

    ok_button = Button(text="OK", handler=on_ok)

    @kb_dialog.add("enter")
    def _(event):
        on_ok()

    fname_input.control.key_bindings = kb_dialog

    dialog = Dialog(
        title="Save File",
        body=fname_input,
        buttons=[ok_button],
        width=60,
        modal=True
    )

    root_container.floats.append(Float(content=dialog))
    layout_main.focus(fname_input.control)

def read_flags():
    flags = []
    try:
        with open(".vanilla_flags.txt", "r", encoding="utf-8") as f:
            for line in f:
                s = line.strip()
                if s:
                    flags.append(s)
    except Exception:
        pass
    return flags

def detect_mode(filename: str):
    global CURRENT_MODE
    if filename.endswith(".c"):
        editor.lexer = PygmentsLexer(CLexer); CURRENT_MODE = "c"
    elif filename.endswith((".cpp", ".cc", ".cxx", ".c++")):
        editor.lexer = PygmentsLexer(CppLexer); CURRENT_MODE = "cpp"
    elif filename.endswith(".py"):
        editor.lexer = PygmentsLexer(PythonLexer); CURRENT_MODE = "py"
    elif filename.endswith(".sh"):
        editor.lexer = PygmentsLexer(BashLexer); CURRENT_MODE = "sh"
    elif filename.endswith(".json"):
        editor.lexer = PygmentsLexer(JsonLexer); CURRENT_MODE = "json"
    elif filename.endswith(".sql"):
        editor.lexer = PygmentsLexer(SqlLexer); CURRENT_MODE = "sql"
    elif filename.endswith((".s", ".asm")):
        editor.lexer = PygmentsLexer(NasmLexer); CURRENT_MODE = "asm"
    elif filename.endswith(".cs"):
        editor.lexer = PygmentsLexer(CSharpLexer); CURRENT_MODE = "cs"
    elif filename.endswith(".html"):
        editor.lexer = PygmentsLexer(HtmlLexer); CURRENT_MODE = "html"
    elif filename.endswith(".js"):
        editor.lexer = PygmentsLexer(JavascriptLexer); CURRENT_MODE = "js"
    else:
        editor.lexer = PygmentsLexer(CLexer); CURRENT_MODE = "c"

def contains_ncurses(text: str) -> bool:
    return "#include <ncurses.h>" in text or '#include "ncurses.h"' in text

def is_port_in_use(port=8000):
    """Vérifie si le port est déjà utilisé"""
    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
        return s.connect_ex(('localhost', port)) == 0

def compile_and_run_for_extension(ext: str):
    flags = read_flags()
    flags_str = " ".join(flags)

    temp_file = "temp" + ext
    with open(temp_file, "w", encoding="utf-8") as f:
        f.write(editor.text)

    if ext in (".c", ".cpp", ".s", ".asm", ".py", ".sh", ".cs"):
        # Gestion standard comme avant
        if ext in (".c", "c", ""):
            compile_cmd = f"gcc {temp_file} -o temp {flags_str}".strip()
            compile_res = subprocess.getoutput(compile_cmd)
            if compile_res.strip():
                return False, f"Compilation errors:\n{compile_res}"
        elif ext in (".cpp", ".cxx", ".cc"):
            compile_cmd = f"g++ {temp_file} -o temp {flags_str}".strip()
            compile_res = subprocess.getoutput(compile_cmd)
            if compile_res.strip():
                return False, f"Compilation errors:\n{compile_res}"
        elif ext in (".s", ".asm"):
            asm_o = "temp.o"
            nasm_res = subprocess.getoutput(f"nasm -f elf64 {temp_file} -o {asm_o} 2>&1")
            if nasm_res.strip() != "":
                compile_cmd = f"gcc {temp_file} -o temp {flags_str} 2>&1"
                compile_res = subprocess.getoutput(compile_cmd)
                if compile_res.strip():
                    return False, f"Compilation errors:\n{compile_res}"
            else:
                ld_res = subprocess.getoutput(f"ld {asm_o} -o temp 2>&1")
                if ld_res.strip():
                    return False, f"Linker errors:\n{ld_res}"
        elif ext == ".py":
            run_out = subprocess.getoutput(f"python3 {temp_file} 2>&1")
            return False, run_out if run_out.strip() else "(no output)"
        elif ext == ".sh":
            os.chmod(temp_file, 0o755)
            run_out = subprocess.getoutput(f"bash {temp_file} 2>&1")
            return False, run_out if run_out.strip() else "(no output)"
        elif ext == ".cs":
            compile_res = subprocess.getoutput(f"mcs {temp_file} -out:temp.exe 2>&1")
            if compile_res.strip():
                return False, f"Compilation errors:\n{compile_res}"
            run_out = subprocess.getoutput("mono temp.exe 2>&1")
            return False, run_out if run_out.strip() else "(no output)"
        elif ext == ".js":
            run_out = subprocess.getoutput(f"node {temp_file} 2>&1")
            return False, run_out if run_out.strip() else "(no output)"

        run_out = subprocess.getoutput("./temp 2>&1")
        return False, run_out if run_out.strip() else "(no output)"

    if ext in (".json", ".sql"):
        return False, "(no execution for this file type — syntax highlighting only)"

    if ext == ".html":
        global HTML_SERVER_STARTED
        # Supprimer les commentaires
        clean_text = re.sub(r"<!--.*?-->", "", editor.text, flags=re.DOTALL)
        temp_file = "temp.html"
        with open(temp_file, "w", encoding="utf-8") as f:
            f.write(clean_text)

        # Lancer le serveur une seule fois si le port est libre
        if not HTML_SERVER_STARTED and not is_port_in_use(8000):
            subprocess.Popen(["python3", "-m", "http.server", "8000"],
                             stdout=subprocess.DEVNULL,
                             stderr=subprocess.DEVNULL)
            HTML_SERVER_STARTED = True

        html_file = os.path.basename(CURRENT_FILE or temp_file)
        url = f"http://localhost:8000/{html_file}"
        webbrowser.open(url)
        return True, f"Serving {html_file} at {url} (Ctrl+C to stop)"

    return False, "(no output)"

# ---- NEW helpers pour lancer/terminer processus externes ----
def find_terminal_emulator():
    """Retourne la commande et le format d'appel pour lancer un terminal interactif."""
    # On essaie dans l'ordre courant : utilitaire / options pratiques
    candidates = [
        ("x-terminal-emulator", ["x-terminal-emulator", "-e"]),  # Debian generic
        ("gnome-terminal", ["gnome-terminal", "--"]),            # GNOME
        ("konsole", ["konsole", "-e"]),                          # KDE
        ("xterm", ["xterm", "-e"]),                              # xterm
        ("alacritty", ["alacritty", "-e"]),                      # alacritty
        ("kitty", ["kitty", "-e"]),                              # kitty
        ("urxvt", ["urxvt", "-e"])
    ]
    for name, proto in candidates:
        if shutil.which(name):
            return proto
    return None

def start_detached_process(key: str, args: list, use_terminal=False, title=None):
    """Démarre et garde la Popen dans RUNNING_PROCS[key]. Si déjà existant, le remplace."""
    # Si déjà lancé -> on le termine proprement avant de relancer.
    if key in RUNNING_PROCS and RUNNING_PROCS[key] is not None:
        stop_process(key)

    if use_terminal:
        term = find_terminal_emulator()
        if term is None:
            # Pas d'émulateur : fallback démarrer en arrière-plan (ne convient pas pour ncurses)
            proc = subprocess.Popen(args, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL, start_new_session=True)
        else:
            # Construire la commande à placer après -e / -- ...
            # On veut que le terminal reste ouvert après la fin (optionnel) : on ajoute `; exec $SHELL`
            cmdstr = " ".join(shlex_quote(a) for a in args)
            # selon terminal, il faut une forme différente
            if term[0].endswith("gnome-terminal"):
                # gnome-terminal -- bash -c "cmd; exec bash"
                proc = subprocess.Popen([term[0], "--", "bash", "-c", f"{cmdstr}; exec bash"], stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
            elif term[0].endswith("konsole"):
                proc = subprocess.Popen([term[0], "-e", "bash", "-c", f"{cmdstr}; exec bash"], stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
            else:
                # xterm / alacritty / kitty acceptent -e "cmd"
                proc = subprocess.Popen([term[0], term[1], "bash", "-c", f"{cmdstr}; exec bash"], stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
    else:
        # Processus détaché normal (pour GUI), on ne redirige pas stdout/stderr pour voir erreurs si besoin
        proc = subprocess.Popen(args, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL, start_new_session=True)

    RUNNING_PROCS[key] = proc
    return proc

def stop_process(key: str, timeout=2.0):
    """Tente terminate(), attend, puis kill() si nécessaire."""
    proc = RUNNING_PROCS.get(key)
    if not proc:
        return False
    try:
        proc.terminate()
    except Exception:
        pass
    # wait with timeout
    try:
        proc.wait(timeout=timeout)
    except subprocess.TimeoutExpired:
        try:
            proc.kill()
        except Exception:
            pass
    finally:
        RUNNING_PROCS.pop(key, None)
    return True

def shlex_quote(s):
    # petit remplacement de shlex.quote pour compatibilité sans import lourd
    import shlex
    return shlex.quote(s)

# ---- Key bindings ----
kb = KeyBindings()

@kb.add("c-x")
def _(event):
    root_container.floats[:] = []
    try:
        subprocess.call("reset", shell=True)
    except Exception:
        pass
    event.app.exit(result=None)

@kb.add("c-o")
def _(event):
    open_save_dialog()

@kb.add("c-k")
def _(event):
    buf = event.app.current_buffer
    doc = buf.document
    before = len(doc.current_line_before_cursor)
    after = len(doc.current_line_after_cursor)
    if doc.cursor_position < len(doc.text):
        after += 1
    buf.delete_before_cursor(before)
    buf.delete(after)

@kb.add("c-n")
def _(event):
    global SPLIT_VIEW
    SPLIT_VIEW = True
    body_container.children[:] = [left_gutter, editor_window, middle_gap, output_window]
    layout_main.focus(editor_window)

# ---- NEW: Ctrl-L toggle pour lancer GUI/ncurses/terminal ----
@kb.add("c-l")
def _(event):
    """
    Ctrl-L:
    - Si fichier Python (.py) -> lance le script en detached (GUI PyQt par ex.)
    - Si fichier C et contient ncurses -> lance l'exécutable dans un terminal séparé
    - Si fichier .sh -> lance le script dans un terminal séparé (utile pour spinner)
    - Si déjà lancé -> arrête le processus et affiche message
    """
    global CURRENT_FILE
    if not CURRENT_FILE:
        output.text = "No current file to run (save first)."
        return

    ext = os.path.splitext(CURRENT_FILE)[1]
    key = f"{TOGGLE_KEY}:{CURRENT_FILE}"
    # If already running -> stop
    if key in RUNNING_PROCS:
        stopped = stop_process(key)
        output.text = f"Stopped process for {CURRENT_FILE}."
        return

    # Save current file before launching
    try:
        save_file(CURRENT_FILE)
    except Exception as e:
        output.text = f"Error saving before launch: {e}"
        return

    # Decide how to launch
    if ext == ".py":
        # GUI Python: start python3 file.py detached
        args = ["python3", CURRENT_FILE]
        start_detached_process(key, args, use_terminal=False)
        output.text = f"Launched Python GUI: {CURRENT_FILE} (detached). Appuyez à nouveau sur Ctrl-L pour fermer."
        return

    if ext == ".sh":
        # Shell script: launch in a terminal so spinner/ncurses shows
        args = ["bash", CURRENT_FILE]
        start_detached_process(key, args, use_terminal=True)
        output.text = f"Launched shell script in new terminal: {CURRENT_FILE}."
        return

    # C / ncurses: compile then run in terminal emulator if it uses ncurses
    if ext in (".c", ".cpp", ".s", ".asm"):
        # compile into temp_exe (non intrusif)
        bin_name = "temp_ncurses_exec"
        if ext == ".c":
            compile_cmd = f"gcc {CURRENT_FILE} -o {bin_name}"
        elif ext in (".cpp", ".cxx", ".cc"):
            compile_cmd = f"g++ {CURRENT_FILE} -o {bin_name}"
        else:
            compile_cmd = None

        if compile_cmd:
            compile_out = subprocess.getoutput(compile_cmd + " 2>&1")
            if compile_out.strip():
                output.text = f"Compilation failed:\n{compile_out}"
                return

            # If source contains ncurses includes -> launch in terminal
            with open(CURRENT_FILE, "r", encoding="utf-8", errors="ignore") as fh:
                txt = fh.read()
            if contains_ncurses(txt):
                args = [os.path.abspath(f"./{bin_name}")]
                start_detached_process(key, args, use_terminal=True)
                output.text = f"Lancé exécutable ncurses dans un terminal: {bin_name}"
                return
            else:
                # Non-ncurses: exécution normale en arrière-plan (mais si interactif, l'utilisateur devrait utiliser terminal)
                args = [os.path.abspath(f"./{bin_name}")]
                start_detached_process(key, args, use_terminal=False)
                output.text = f"Lancé exécutable: {bin_name} (détaché)"
                return

    # JS, cs, etc. -> comportement par défaut : lancer en detached
    if ext == ".js":
        args = ["node", CURRENT_FILE]
        start_detached_process(key, args, use_terminal=False)
        output.text = f"Lancé node {CURRENT_FILE} (détaché)."
        return

    # fallback
    args = ["bash", "-c", f"python3 {CURRENT_FILE}"]
    start_detached_process(key, args, use_terminal=True)
    output.text = f"Lancé (fallback) {CURRENT_FILE} dans un terminal."

@kb.add("c-b")
def _(event):
    ext = os.path.splitext(CURRENT_FILE or (sys.argv[1] if len(sys.argv) > 1 else ""))[1]
    # Sauvegarde du fichier courant
    if CURRENT_FILE:
        save_file(CURRENT_FILE)

    # HTML spécifique
    if ext == ".html":
        temp_file = "temp.html"
        clean_text = re.sub(r"<!--.*?-->", "", editor.text, flags=re.DOTALL)
        with open(temp_file, "w", encoding="utf-8") as f:
            f.write(clean_text)

        # Lancer serveur silencieux si port libre
        global HTML_SERVER_STARTED
        if not HTML_SERVER_STARTED and not is_port_in_use(8000):
            subprocess.Popen(
                ["python3", "-m", "http.server", "8000"],
                stdout=subprocess.DEVNULL,
                stderr=subprocess.DEVNULL
            )
            HTML_SERVER_STARTED = True

        html_file = os.path.basename(CURRENT_FILE)
        url = f"http://localhost:8000/{html_file}"
        webbrowser.open(url)

        # Quitter Abyss mais renvoyer le fichier pour le relancer automatiquement
        event.app.exit(result=CURRENT_FILE)
        return

    # Pour les autres fichiers
    handled_in_terminal, message = compile_and_run_for_extension(ext)
    output.text = message
    if handled_in_terminal and ext != ".html":
        event.app.exit()
        os.system("./temp && clear")


# ---- Autopairs ----
pairs = {"{": "}", "(": ")", "[": "]", "\"": "\"", "'": "'", "<": ">"}
for opening, closing in pairs.items():
    @kb.add(opening)
    def _(event, opening=opening, closing=closing):
        buf = event.app.current_buffer
        buf.insert_text(opening + closing)
        buf.cursor_left()

# ---- Auto-indent & auto-close HTML tags ----
@kb.add("enter")
def _(event):
    buf = event.app.current_buffer
    doc: Document = buf.document
    before = doc.text_before_cursor.rstrip()

    # C-style braces
    if before.endswith("{"):
        m = re.match(r'(\s*)', doc.current_line_before_cursor)
        base_indent = m.group(1) if m else ""
        inner = base_indent + "    "
        pos0 = buf.cursor_position
        buf.insert_text("\n" + inner + "\n" + base_indent)
        buf.cursor_position = pos0 + 1 + len(inner)
        return

    # Python indent
    if CURRENT_MODE == "py" and before.endswith(":"):
        m = re.match(r'(\s*)', doc.current_line_before_cursor)
        base_indent = m.group(1) if m else ""
        buf.insert_text("\n" + base_indent + "    ")
        return

    # ASM labels
    if CURRENT_MODE == "asm" and before.endswith(":"):
        m = re.match(r'(\s*)', doc.current_line_before_cursor)
        base_indent = m.group(1) if m else ""
        buf.insert_text("\n" + base_indent + "    ")
        return

    # HTML auto-close tags
    if CURRENT_MODE == "html":
        m = re.match(r'(\s*)<([a-zA-Z0-9]+)>$', doc.current_line_before_cursor.strip())
        if m:
            base_indent = re.match(r'(\s*)', doc.current_line_before_cursor).group(1) or ""
            tag = m.group(2)
            inner_indent = base_indent + "    "
            pos0 = buf.cursor_position
            buf.insert_text("\n" + inner_indent + "\n" + base_indent + f"</{tag}>")
            buf.cursor_position = pos0 + 1 + len(inner_indent)
            return

    # Comportement par défaut
    buf.newline()

# ---- Application ----
app = Application(layout=layout_main, key_bindings=kb, full_screen=True)

# ---- Main runner ----
if __name__ == "__main__":
    if len(sys.argv) > 1:
        arg = sys.argv[1]
        if arg != "vide" and os.path.exists(arg):
            CURRENT_FILE = arg
            with open(arg, "r", encoding="utf-8") as fh:
                editor.text = fh.read()
            detect_mode(arg)
    else:
        detect_mode("file.c")

    try:
        result = app.run()
    finally:
        try:
            subprocess.call("reset", shell=True)
        except Exception:
            pass
        for f in glob.glob("temp.*"):
            try:
                os.remove(f)
            except Exception:
                pass

    if result and isinstance(result, str):
        os.execv(sys.executable, [sys.executable, sys.argv[0], result])
